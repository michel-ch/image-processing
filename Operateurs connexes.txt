.. _Connexite:

Operateurs connexes
===================

Les exercices a realiser sont situes dans la base de code que vous recuperez en vous inscrivant sur le lien GitHub classroom recu par mail [1]_. Lisez bien le readme du depot pour comprendre comment l'utiliser. La majorite des fonctions demandees existent deja dans OpenCV : **le but n'est pas d'utiliser les fonctions d'OpenCV mais de les coder vous meme !** Nous utiliserons donc uniquement les conteneurs de base d'OpenCV et les fontions d'entree/sortie.

.. important::

	**Au cours de ce chapitre, vous completerez le fichier ``tpConnectedComponent.cpp`` que vous devrez pousser sur votre depot git avant la prochaine seance (cf. consignes detaillees envoyees par mail).**


Adjacence
*********

Dans le premier chapitre nous avons vu les traitements d'histogramme qui modifient une image sans consideration pour les aspects spatiaux : la facon dont la valeur d'un pixel est modifiee ne depend pas de sa position dans l'image. Dans ce deuxiÃ¨me chapitre nous nous interesserons aux relations de voisinnage entre les pixels et aux traitements qui exploitent principalement cette information.

Une image digitale peut etre vue comme une grille de pixels *carres* a coordonnees entiÃ¨res dans :math:`\mathbb{Z}^2`, on parle de *pavage*, dans laquelle un pixel peut avoir 4 ou 8 pixels voisins :

.. figure:: grille.png
	:width: 450px
	:align: center
	
	Grille des pixels. A gauche, representation du 4-voisinnage : le pixel bleu est voisin des 4 pixels jaunes situes a gauche, a droite, au dessus et en dessous. A droite, representation du 8-voisinnage : le pixel bleu est voisin des 8 pixels jaunes qui l'entourent (les 4 directions precendentes plus les diagonales).
	
On peut formaliser ces relations de voisinnage en definissant l'ensemble des pixels voisins d'un point de coordonnees :math:`p=(x,y)\in\mathbb{Z}^2`. L'ensemble des 4-voisins de :math:`p`, note :math:`N_4(p)` est donne par :

.. math::

	N_4((x, y))=\{(i,j)\in\mathbb{Z}^2 \ |\ |x-i| + |y-j| = 1 \}.
	
De maniÃ¨re similaire, l'ensemble des 8-voisins de :math:`p`, note :math:`N_8(p)` est donne par :

.. math::

	N_8((x, y))=\{(i,j)\in\mathbb{Z}^2 \ |\ \max(|x-i|,|y-j|) = 1 \}.
	
Ceci conduit en fait a definir deux graphes, le graphe de 4-adjacence et le graphe de 8-adjacence :

.. figure:: graphe.png
	:width: 450px
	:align: center
	
	Chaque pixel represente un noeud du graphe, les arretes sont donnees par les relations d'adjacence :math:`N_4` a gauche et :math:`N_8` a droite.

Ce modÃ¨le permet de reutiliser les algorithmes de graphes (plus court chemin, composantes connexes, arbre couvrant de poids minimum...) pour analyser et traiter les images.

Composantes connexes
********************

Un *chemin* :math:`A_{pq}` d'un pixel :math:`p` a un pixel :math:`q` est une sequence de pixels :math:`(x_1,\ldots,x_n)` telle que :

* :math:`p` et :math:`q` sont le depart et l'arrivee de :math:`A_{pq}` : :math:`x_1=p` et :math:`x_n=q`
* 2 points consecutifs de :math:`A_{pq}` sont voisins : :math:`\forall i=1,\ldots,n-1, \ x_{i+1}\in N(x_i)`

Un ensemble de pixels  :math:`X` est dit *connexe* si, pour toute paire de pixels :math:`\{p, q\}` dans :math:`X`, il existe un chemin de :math:`p` a :math:`q` dont tous les pixels sont contenus dans :math:`X`.

Une *composante connexe*   d'un ensemble de pixels  :math:`X` est un sous ensemble :math:`Y\subseteq X` tel que:

* :math:`Y` est connexe,
* :math:`Y` est maximal pour la connexite : si on ajoute un pixel de :math:`X` a :math:`Y` alors ce dernier n'est plus connexe.  

.. figure:: cc.png
	:align: center
	:width: 350px
	
	Exemple d'une image binaire, dont les pixels sont representes par des ronds noirs. En 4-connexite, cette image comporte 5 composantes connexes. En 8-connexite, les composantes 1-2-3 et 4-5 fusionnent ne laissant que 2 composantes connexes. 
	
L'algorithme fondamental qui nous interessera par la suite est le parcours de composantes connexes. Il prend en entree: 

* une image binaire : l'image a traiter,
* un pixel :math:`p` de l'image : la composante connexe contenant ce pixel sera parcourue,
* une procedure prenant un pixel en paramÃ¨tre : cette procedure sera appelee une fois sur chaque pixel de la composante connexe parcourue.

Il existe plusieurs variantes de cet algorithme, en voila une qui effectue un parcours en profondeur au moyen d'une pile :

.. code-block:: none

	def parcoursCC(image im, pixel p, callback c):
		pour tout pixel r de im:
			visiter(r) <- faux
		Pile s
		s.empiler(p)
		Tant que s n'est pas vide:
			point r = s.pop()
			c(r)
			pour tout voisin v de r:
				si v est dans im et visiter(v) est faux:
					visiter(v) <- vrai
					s.empiler(v)

Cet algorithme s'execute en temps lineaire :math:`\mathcal{O}(n)` (avec :math:`n` le nombre pixels dans l'image) : 

* la condition sur ``visiter(v)`` garantit qu'un pixel ne peut pas etre mis plusieurs fois dans la pile : le nombre d'iterations de la boucle ``tant que`` externe est donc borne par le nombre pixels,
* le nombre d'iterations sur la boucle ``pour tout`` interne est constant (4 ou 8 selon l'adjacence choisie),
* dans le pire cas, la composante connexe s'etend sur toute l'image obligeant a visiter tous les pixels de l'image.

.. tip::
	
	Parcourir les voisins d'un pixels est une operation courante en traitement d'image. Une solution elegante est d'encoder la relation de voisinnage sous forme d'une liste de points avec des coordonnees relatives: 
	
	.. code-block:: cpp
		
		vector<Point2i> neighbours = {{-1,0}, {0,-1}, {0,1}, {1,0}};
		
		Point2i pixel = {24, 12}; // coordonnees d'un pixel
		
		//parcours des voisins de p
		for(Point2i neighbour: neighbours)
		{
			neighbour += pixel;
		}
  
.. tip::

	Une image binaire peut-etre vue comme une fonction dans :math:`\{0,1\}` ou comme un ensemble. D'un point de vue algorithmique/mathematique, la vision ensembliste est souvent plus simple (les ensembles sont des objets plus simples que les fonctions). 
	
	Sous OpenCV, les images sont representees par des tableaux (donc des fonctions) et le type binaires n'est pas supporte (les operations bits a bits ne sont pas efficaces sur les ordinateurs modernes). Les images binaires sont alors generalement representees comme des images a niveaux de gris et on considÃ¨re qu'un pixel de valeur non nulle est present dans l'image.
	
	
 
Labelisation
************ 

*L'etiquetage en composantes connexes* ou *labelisation* consiste a parcourir une image binaire en assignant un numero a chaque composante connexe de l'image. Le resultat de l'etiquetage est une nouvelle image, de meme dimension que l'image binaire d'entree, et dont la valeur d'un pixel est egale au numero de la composante connexe auquel il appartient.

.. figure:: labelisation.png
	:width: 450px
	:align: center
	
	A gauche une image binaire composee de 2 composantes connexes (en noir). A droite : resultat de l'etiquetage en composantes connexes de l'image de gauche.
	
.. figure:: labelisation2.png
	:width: 450px
	:align: center
	
	A gauche une image binaire (pixels blancs). A droite : resultat de l'etiquetage en composantes connexes de l'image de gauche: afin de faciliter la visualisation, une couleur aleatoire a ete assignee a chaque composante connexe au lieu d'un numero.
	
.. quiz:: tp2-label
	:title: Etiquetage en composantes connexes
	

	Adaptez l'algorithme ``parcoursCC`` pour implementer l'etiquetage en composantes connexes (avec la 4-adjacence) dans la fonction ``ccLabel`` du fichier ``tpConnectedComponents.cpp``. Pensez a valider votre implementation avec la commande ``test``. 
	
.. quiz:: tp2-areaFilter
	:title: Filtre d'aire
	
	Le filtre d'aire est un operateur qui supprime toute les composantes connexes d'une image dont la taille (mesuree par le nombre de pixels dans la composante) est strictement inferieure a un seuil donne.

	Implementez un filtre d'aire dans la fonction ``ccAreaFilter`` (avec la 4-adjacence) du fichier ``tpConnectedComponents.cpp``. Pensez a valider votre implementation avec la commande ``test``. 
	
.. quiz:: tp2-label2
	:title: Etiquetage en composantes connexes - Mieux
	
	La fonction de labelisation implementee precedemment realise une exploration en profondeur (ou en largeur) des composantes connexes de l'image. Cette approche a une complexite lineaire, ce qui est optimal d'un point de vue theorique. En pratique cet algorithme a neanmoins le desavantage de realiser des accÃ¨s aleatoires en memoire qui penalisent ses performances (la memoire cache est sous utilisee et les defauts de page sont frequents). 
	
	Il existe un autre algorithme de labelisation en composantes connexes qui traite l'image en 2 passes (les pixels sont parcourus deux fois, ligne par ligne) qui a donc l'avantage de parcourir la memoire dans l'ordre, ce qui lui permet d'etre plus performant pratique. Implementez `l'algorithme de labelisation en 2 passes <https://en.wikipedia.org/wiki/Connected-component_labeling#Two-pass>`_ dans la fonction ``ccTwoPassLabel`` dans le fichier ``tpConnectedComponents.cpp``.

.. [1] La base de code est egalement recuperable `ici <https://github.com/PerretB/ImageProcessingLab>`_