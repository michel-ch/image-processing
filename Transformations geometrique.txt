.. _Geometrie:

Transformations geometriques
============================

Les exercices a  realiser sont situes dans la base de code que vous recuperez en vous inscrivant sur le lien GitHub classroom recu par mail [1]_. Lisez bien le readme du depot pour comprendre comment l'utiliser. La majorite des fonctions demandees existent deja  dans OpenCV : **le but n'est pas d'utiliser les fonctions d'OpenCV mais de les coder vous meme !** Nous utiliserons donc uniquement les conteneurs de base d'OpenCV et les fontions d'entree/sortie.

.. important::

	**Au cours de ce chapitre, vous completerez le fichier ``tpGeometry.cpp`` que vous devrez pousser sur votre depot git avant la prochaine seance (cf. consignes detaillees envoyees par mail).**


Transformations
***************

Certaines transfromations geometriques sont triviales a  realiser car elles ne reposent que sur un jeu d'indices. Dans cette categorie on retrouve notamment:

* les translations par un vecteur de coordonnees entieres,
* les rotations d'angles multiples de :math:`90Â°`,
* les symmetries verticales ou horizontales.

.. figure:: translation.png
	:width: 450px
	:align: center
	
	L'image *g* correspond a  la translation de l'image *f* par le vecteur *c*. Formellement on a :math:`g(p)=f(p-c)`.

.. figure:: transposee.png
	:width: 450px
	:align: center
	
	L'image *g* correspond a  la transposee de l'image *f*. Formellement on a :math:`g((x,y))=f((y,x))`.

.. quiz:: tp3-transpose
	:title: Transposee d'une image
	

	Implementez la transposee d'image dans la fonction ``transpose`` du fichier ``tpGeometry.cpp``. Pensez a  valider votre implementation avec la commande ``test``. 
	
Dans le cas general, une transformation geometrique est une fonction :math:`\phi:\mathbb{R}^2\rightarrow\mathbb{R}^2` qui a chaque point du plan associe un autre point du plan. Toutes les transformations geometriques simples et leurs combinaisons entrent dans ce cadre : rotations, translations, homotethies, symmetries...

Neanmoins, l'application directe d'une transformation quelconque :math:`\phi` pose probleme car l'image d'un pixel :math:`p=(x,y)\in\mathbb{Z}^2` de coordonnees entieres par :math:`\phi` ne donnera generalement pas un resultat en coordonnees entieres : :math:`\phi(p)\notin\mathbb{Z}^2` : 

.. figure:: phi0.png
	:width: 550px
	:align: center
	
	L'image du pixel :math:`p` par la transformation :math:`\phi` ne tombe pas exactement sur un pixel de l'image transformee : comment faire pour trouver les valeurs des pixels de l'image transformee ?
	
L'idee pour resoudre ce probleme est d'inverser la question que l'on se pose : plutot que de chercher la position d'un pixel de l'image d'origine apres transformation, on va chercher quelle etait la position d'un pixel de l'image resultat avant transformation. On va donc utiliser la transformation inverse  :math:`\phi^{-1}` :

.. figure:: phi.png
	:width: 550px
	:align: center
	
	L'application inverse :math:`\phi^{-1}` associe a  chaque pixel de l'image transfomee un point dans l'image d'origine.

Mais l'image de :math:`\phi^{-1}(q)` ne tombe pas non plus exactement sur un pixel de l'image d'origine ! Cette fois on peut neanmoins s'en sortir en interpolant la valeur de l'image d'origine au point :math:`\phi^{-1}(q)` en utilisant les valeurs des pixels connues.
	

Interpolation 2D
****************

Les 3 principales methodes d'interpolation 2D sont :

* plus proche voisin,
* bilineaire,
* bicubique.

Schematiquement, on peut representer ces 3 processus d'interpolation, en 1D et 2D de la maniere suivante :

.. figure:: interp.svg
	:width: 550px
	:align: center
	
	Dans ces illustrations, les valeurs des fonctions aux points rouges, jaunes, verts et bleus sont connues. Le but est de determiner la valeur interpolee au niveau du point noir. Les courbes grises representent les courbes interpolees.
	L'interpolation par plus proche voisin consiste a  utiliser la valeur du point connu le plus proche. L'interpolation lineaire consiste a  tracer des droites entre les points connus les plus proches : en 1D il faut 2 points, en 2D il en faut 4. L'interpolation cubique consiste a  tracer des polynomes de degre 3 entre les points connus les plus proches : en 1D il faut 4 points, en 2D il en faut 16 (Source de l'image `Wikipedia <https://fr.wikipedia.org/wiki/Interpolation_bicubique>`_).


Sur une image ces 3 methodes d'interpolation vont produire des images de plus en plus lisses :

.. figure:: interpIm.png
	:width: 550px
	:align: center
	
	Effets des differentes interpolations sur une meme image. Les points de l'image d'origine sont marques en noir, tous les autres points sont interpoles a  partir des valeurs des points noirs.
	
Nous allons voir le fonctionnement des 2 premieres methodes d'interpolation : par plus proche voisin et bilineaire. `L'interpolation bicubique <https://fr.wikipedia.org/wiki/Interpolation_bicubique>`_ n'est pas beaucoup plus compliquee en theorie mais sa mise en oeuvre est assez fastidieuse car il faut regarder la valeur de 16 points de l'images pour interpoler une valeur.




L'interpolation par plus proche voisin consiste simplement a  attribuer a  un point :math:`\phi^{-1}(q)` de coordonnees reelles, la valeur du pixel :math:`p` (de coordonnees entieres) le plus proche de :math:`\phi^{-1}(q)` :
	
.. image:: plusprochevoisin.png
	:width: 550px
	:align: center
	
Etant donnee une image :math:`f:\mathbb{Z}^2\rightarrow\mathbb{R}`, on peut definir l'image :math:`F:\mathbb{R}^2\rightarrow\mathbb{R}` correspondant a  l'interpolation par plus proche voisin de :math:`f` de la maniere suivante :

.. math::

	\forall (x,y)\in\mathbb{R}^2, F(x,y) = f(\lfloor x+0.5 \rfloor, \lfloor y+0.5 \rfloor)

Notez que :math:`\lfloor x+0.5 \rfloor` correspond a  prendre l'arrondi de :math:`x`, c'est-a -dire l'entier le plus proche.
	
.. quiz:: tp3-cn
	:title: Agrandisssement d'image et interpolation par plus proche voisin
	
	Implementez l'interpolation par plus proche voisin dans la fonction ``interpolate_nearest`` du fichier ``tpGeometry.cpp``. Implementez la fonction ``expand`` du fichier ``tpGeometry.cpp`` qui agrandit une image en utilisant une fonction d'interpolation. Pensez a  valider votre implemantion avec la commande ``test`` (l'executable genere s'appelle ``expand``). 
	
L'interpolation bilineaire est construite a  partir de l'interpolation lineaire 1D. En 1D, le principe est le suivant:

* on connait la valeur de la fonction :math:`f` aux points :math:`x_1` et :math:`x_2`,
* on souhaite interpoler :math:`f` au point :math:`x_3` tel que :math:`x_1 \leq x_3 \leq x_2`.

On fait l'hypothese que :math:`f` est affine (forme un segment de droite) sur l'intervalle :math:`[x_1,x_2]` :

.. image:: linear1D.png 
	:width: 200px
	:align: center

On deduit (c'est le meme probleme que la normalisation d'histogramme) :

.. math::

	f(x_3) = (x_3-x_1)\frac{f(x_2)-f(x_1)}{x_2-x_1} + f(x_1)
	
Que l'on peut egalement ecrire :

.. math::

	f(x_3) = (1-\alpha)f(x_1) + \alpha f(x_2)
	
avec :math:`\alpha = \frac{x_3-x_1}{x_2-x1}\in[0,1]` : :math:`\alpha` represente la proportion de :math:`f(x_2)` et :math:`1-\alpha` la proportion :math:`f(x_1)` dans :math:`f(x_3)`.

En 2D, on part du principe suivant :

* on connait la valeur de la fonction :math:`f` aux points :math:`(x_1, y_1)`, :math:`(x_1, y_2)`, :math:`(x_2, y_1)`  et :math:`(x_2, y_2)`,
* on souhaite interpoler :math:`f` au point :math:`(x_3, y_3)` tel que :math:`x_1 \leq x_3 \leq x_2` et :math:`y_1 \leq y_3 \leq y_2` :

.. image:: linear2D.png
	:width: 200px
	:align: center

L'interpolation bilineaire est realisee en 3 etapes :

1. On realise une interpolation 1D entre :math:`(x_1, y_1)`, :math:`(x_2, y_1)` pour trouver la valeur de :math:`f` au point :math:`(x_3, y_1)`.
2. On realise une interpolation 1D entre :math:`(x_1, y_2)`, :math:`(x_2, y_2)` pour trouver la valeur de :math:`f` au point :math:`(x_3, y_2)`.
3. On realise une interpolation 1D entre :math:`(x_3, y_1)`, :math:`(x_3, y_2)`, les 2 points interpoles precedemment, pour trouver la valeur de :math:`f` au point :math:`(x_3, y_3)`.

On peut montrer que ce processus revient a  la formule suivante :

.. math:: 

	f(x_3,y_3) = (1-\alpha)(1-\beta)f(x_1,y_1) + \alpha(1-\beta)f(x_2,y_1) + (1-\alpha)\beta f(x_1,y_2) + \alpha\beta f(x_2,y_2)
	
avec :math:`\alpha = \frac{x_3-x_1}{x_2-x1}\in[0,1]` et :math:`\beta = \frac{y_3-y_1}{y_2-y1}\in[0,1]`.
	

	
	
.. quiz:: tp3-bl
	:title: Agrandisssement d'image et interpolation bilineaire
	
	Implementez l'interpolation bilineaire dans la fonction ``interpolate_bilinear`` du fichier ``tpGeometry.cpp``. Pensez a  valider votre implemantion avec la commande ``test`` (l'executable genere s'appelle ``expand``). 
	
	Notez que pour appliquer la formule d'interpolation bilineaire, on connait les coordonnees du point a  interpoler :math:`(x_3,y_3)\in\mathbb{R}^2` mais il faut determiner les coordonnees des points  :math:`(x_1,y_1)\in\mathbb{Z}^2` et :math:`(x_2,y_2)\in\mathbb{Z}^2`. Remarquez qu'on peut fixer :math:`x_1=\lfloor x_3 \rfloor` et :math:`y_1=\lfloor y_3 \rfloor`.
	
.. quiz:: tp3-rotation
	:title: Rotation
	
	Implementez la transformation de rotation d'image dans la fonction ``rotate`` du fichier ``tpGeometry.cpp``. Pensez a  valider votre implemantion avec la commande ``test`` (l'executable genere s'appelle ``rotate``). 
	
	Le choix de la fonction d'interpolation est particulierement important dans le cas de la rotation. En prenant l'image ci-dessous :
	
	.. image:: exMap.png
		:align: center
	
	une rotation avec les differentes methodes d'interpolations donnent les resultats suivants :
	
	.. image:: exMapRot.png
		:align: center
		
	On voit clairement des effets d'aliasing (des lignes continues deviennent discontinues) apparaitrent avec l'interpolation par plus proche voisin. L'interpolation bilineaire ameliore la situation, mais le contraste est diminue. L'interpolation bicubique donne le meilleur resultat.	
	
	Notez que la rotation change en generale la taille de l'image. Ici, on choisit de laisser les parties de l'image transformee qui ne tombent pas dans l'image d'origine en noir.

.. [1] La base de code est egalement recuperable `ici <https://github.com/PerretB/ImageProcessingLab>`_